# マルチLLMオーケストレーション - アーキテクチャ決定記録

## 概要

現在の単一プロンプト・オーケストレーターを、Grasp設定可能な複数プロンプト対応システムに拡張する。
時系列メモ機能により、複数のLLMが協調して会議を監視・介入できるようにする。

## アーキテクチャの主要決定事項

### システム統合アプローチ
- **方針**: 既存オーケストレーターワーカーが一連のGraspによってLLMのレスポンスを処理する。
- **理由**: 
  - 1つのMeetingは特定のオーケストレーターコンテナで処理するので、その中ですべて処理するのが合理的
  - 一連のGraspは時系列メモを残したり、そのメモを参照したりする。このメモはミーティング中だけ参照できればよいので、コンテナのメモリ上に保存するのが便利

### データストレージ設計

#### 時系列メモ（TemporalNotesStore）
- **保存先**: メモリ内（揮発性）
- **実装**: `TemporalNotesStore` クラス（Map<meetingId, Map<tag, Note[]>>）
- **TTL**: 会議終了後のクリーンアップ（実装は将来）
- **理由**:
  - 会議中の一時的な状態共有が目的で、永続化は不要
  - DynamoDBへの頻繁な書き込みを避けコスト削減
  - 各ミーティングは単一のECSタスクで処理されるため、メモリ内で状態を保持できる
    （SQS FIFOのMessageGroupIdにより、同一ミーティングのメッセージは同じタスクに配信される）

## 主要な技術的決定

### テンプレート変数構文
- **採用**: Handlebars風の構文（`{{INPUT}}`, `{{NOTES:tag:latest3}}`）
- **理由**:
  - シンプルで理解しやすい
  - サンドボックス化が容易（任意コード実行を防ぐ）
  - YAMLと組み合わせて可読性が高い

### LLMレスポンス解析
- **第一優先**: 厳密なJSON形式を期待（`{"should_intervene": boolean, "reason": string, "message": string}`）
- **フォールバック**: Markdownコードブロック（```json ... ```）から抽出
- **エラーハンドリング**: パース失敗時はログ記録し、介入なしとして扱う
- **理由**: LLMは時々マークダウンで囲んで返すため、柔軟な解析が必要

## リスクと対策

### リスク1: オーケストレーター再起動でメモ消失
- **影響**: 会議を処理中のECSコンテナが再起動すると、その会議のTemporalNotesStoreの内容が失われる
- **対策**:
  - ヘルスチェックと安定したデプロイメントでコンテナ再起動を最小化
  - 将来的にRedis/DynamoDBへの永続化を検討
- **理由**: PoC段階では揮発性で十分。永続化はコストと複雑さが増すため後回し

### リスク2: Grasp設定エラーでクラッシュ
- **影響**: YAML構文エラーや不正な変数参照でオーケストレーターが停止
- **対策**:
  - 設定読み込み時の厳密な検証（スキーマチェック、変数存在確認）
  - Grasp実行のtry-catchサンドボックス化
  - 起動時の設定検証失敗時はデフォルト設定で起動
- **理由**: 設定ミスで全体が止まるのは避けたい

### リスク3: LLM APIレート制限
- **影響**: 複数のGraspが同時実行されるとレート制限に達する
- **対策**:
  - Grasp毎のcooldownMs設定
  - グローバルクールダウン（2秒）ですべてのGrasp実行間に間隔を確保
  - CloudWatchメトリクスで監視（将来）
- **理由**: Bedrock APIには控えめなレート制限があるため、間隔制御が必須

### リスク4: レスポンス解析の失敗
- **影響**: LLMが期待しない形式で返すと介入できない
- **対策**:
  - JSON解析失敗時のフォールバック（マークダウンコードブロック抽出）
  - プロンプトにレスポンス形式を明示
  - 失敗時はログ記録して継続（クラッシュしない）
- **理由**: LLMの出力は完全には制御できないため、柔軟な対応が必要
